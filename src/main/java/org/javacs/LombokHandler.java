package org.javacs;

import com.sun.source.tree.ClassTree;
import com.sun.source.tree.CompilationUnitTree;
import com.sun.source.tree.IdentifierTree;
import com.sun.source.tree.MemberSelectTree;
import com.sun.source.tree.MethodInvocationTree;
import com.sun.source.tree.MethodTree;
import com.sun.source.tree.VariableTree;
import com.sun.source.tree.Tree;
import com.sun.source.util.TreePath;
import com.sun.source.util.TreePathScanner;
import com.sun.source.util.Trees;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeVariable;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import org.javacs.lsp.CompletionItem;
import org.javacs.lsp.CompletionItemKind;
import org.javacs.lsp.CompletionList;
import org.javacs.lsp.DiagnosticSeverity;
import org.javacs.lsp.InsertTextFormat;
import org.javacs.lsp.Location;
import org.javacs.lsp.ParameterInformation;
import org.javacs.lsp.SignatureHelp;
import org.javacs.lsp.SignatureInformation;
import org.javacs.lsp.Position;
import org.javacs.lsp.Range;

public final class LombokHandler {
    private LombokHandler() {}

    public static LombokMetadata metadataForClass(
            CompileTask task, String qualifiedName, LombokMetadataCache cache) {
        var classTree = findClassTree(task.roots, qualifiedName);
        if (classTree != null) {
            var metadata = LombokSupport.analyze(classTree);
            if (!LombokSupport.hasLombokAnnotations(metadata)) return null;
            return metadata;
        }
        if (cache != null) {
            return cache.getFromSource(qualifiedName);
        }
        return null;
    }

    public static void addCompletions(
            CompileTask task,
            TypeElement typeElement,
            String partial,
            List<CompletionItem> list,
            LombokMetadataCache cache) {
        var qualifiedName = typeElement.getQualifiedName().toString();
        var metadata = metadataForClass(task, qualifiedName, cache);
        if (metadata == null) {
            return;
        }

        var existing = new HashSet<String>();
        for (var item : list) {
            if (item.label != null) {
                existing.add(item.label);
            }
        }

        if (metadata.hasGetter || metadata.hasData || metadata.hasValue) {
            for (var getterName : metadata.getGeneratedGetterNames()) {
                if (existing.contains(getterName)) continue;
                if (StringSearch.matchesPartialName(getterName, partial)) {
                    var item = new CompletionItem();
                    item.label = getterName;
                    item.kind = CompletionItemKind.Method;
                    item.insertText = getterName + "()";
                    item.insertTextFormat = InsertTextFormat.PlainText;
                    item.detail = "(generated by Lombok)";
                    list.add(item);
                }
            }
        }

        if ((metadata.hasSetter || metadata.hasData) && !metadata.hasValue) {
            for (var setterName : metadata.getGeneratedSetterNames()) {
                if (existing.contains(setterName)) continue;
                if (StringSearch.matchesPartialName(setterName, partial)) {
                    var item = new CompletionItem();
                    item.label = setterName;
                    item.kind = CompletionItemKind.Method;
                    item.insertText = setterName + "($1)";
                    item.insertTextFormat = InsertTextFormat.Snippet;
                    item.detail = "(generated by Lombok)";
                    list.add(item);
                }
            }
        }

        if (metadata.hasToString && StringSearch.matchesPartialName("toString", partial)) {
            if (existing.contains("toString")) return;
            var item = new CompletionItem();
            item.label = "toString";
            item.kind = CompletionItemKind.Method;
            item.insertText = "toString()";
            item.insertTextFormat = InsertTextFormat.PlainText;
            item.detail = "(generated by Lombok)";
            list.add(item);
        }

        if (metadata.hasEqualsAndHashCode && StringSearch.matchesPartialName("equals", partial)) {
            if (existing.contains("equals")) return;
            var item = new CompletionItem();
            item.label = "equals";
            item.kind = CompletionItemKind.Method;
            item.insertText = "equals($1)";
            item.insertTextFormat = InsertTextFormat.Snippet;
            item.detail = "(generated by Lombok)";
            list.add(item);
        }

        if (metadata.hasEqualsAndHashCode && StringSearch.matchesPartialName("hashCode", partial)) {
            if (existing.contains("hashCode")) return;
            var item = new CompletionItem();
            item.label = "hashCode";
            item.kind = CompletionItemKind.Method;
            item.insertText = "hashCode()";
            item.insertTextFormat = InsertTextFormat.PlainText;
            item.detail = "(generated by Lombok)";
            list.add(item);
        }
    }

    public static void addStaticCompletions(
            CompileTask task,
            TypeElement typeElement,
            String partial,
            List<CompletionItem> list,
            LombokMetadataCache cache) {
        var qualifiedName = typeElement.getQualifiedName().toString();
        var metadata = metadataForClass(task, qualifiedName, cache);
        if (metadata == null || !metadata.hasBuilder) {
            return;
        }
        if (metadata.explicitMethodNames.contains(metadata.builderMethodName)) return;

        var existing = new HashSet<String>();
        for (var item : list) {
            if (item.label != null) {
                existing.add(item.label);
            }
        }
        if (existing.contains(metadata.builderMethodName)) return;
        if (!StringSearch.matchesPartialName(metadata.builderMethodName, partial)) return;

        var item = new CompletionItem();
        item.label = metadata.builderMethodName;
        item.kind = CompletionItemKind.Method;
        item.insertText = metadata.builderMethodName + "()";
        item.insertTextFormat = InsertTextFormat.PlainText;
        item.detail = "(generated by Lombok builder)";
        list.add(item);
    }

    public static CompletionList builderCompletionsForInvocation(
            CompileTask task,
            MethodInvocationTree invocation,
            String partial,
            LombokMetadataCache cache,
            CompilerProvider compiler) {
        var trees = Trees.instance(task.task);
        var select = invocation.getMethodSelect();
        if (!(select instanceof MemberSelectTree)) return null;
        var memberSelect = (MemberSelectTree) select;
        var methodName = memberSelect.getIdentifier().toString();

        var ownerPath = trees.getPath(task.root(), memberSelect.getExpression());
        if (ownerPath == null) return null;
        TypeElement ownerType = null;
        var ownerElement = trees.getElement(ownerPath);
        if (ownerElement instanceof TypeElement) {
            ownerType = (TypeElement) ownerElement;
        } else {
            ownerType = typeElement(trees.getTypeMirror(ownerPath));
        }
        LombokMetadata metadata = null;
        if (ownerType != null) {
            metadata = metadataForClass(task, ownerType.getQualifiedName().toString(), cache);
        } else if (memberSelect.getExpression() instanceof IdentifierTree && cache != null && compiler != null) {
            var simpleName = ((IdentifierTree) memberSelect.getExpression()).getName().toString();
            var qualified = resolveTypeName(task, compiler, task.root(), simpleName);
            if (qualified != null) {
                metadata = cache.getFromSource(qualified);
            }
        }
        if (metadata == null || !metadata.hasBuilder) return null;
        if (!methodName.equals(metadata.builderMethodName)) return null;
        if (metadata.explicitMethodNames.contains(metadata.builderMethodName)) return null;
        if (metadata.explicitInnerTypeNames.contains(metadata.builderClassName)) return null;

        var list = new ArrayList<CompletionItem>();
        for (var builderSetter : metadata.getBuilderSetterNames()) {
            if (!StringSearch.matchesPartialName(builderSetter, partial)) continue;
            var item = new CompletionItem();
            item.label = builderSetter;
            item.kind = CompletionItemKind.Method;
            item.insertText = builderSetter + "($1)";
            item.insertTextFormat = InsertTextFormat.Snippet;
            item.detail = "(generated by Lombok builder)";
            list.add(item);
        }
        if (!metadata.explicitBuilderMethodNames.contains(metadata.buildMethodName)
                && StringSearch.matchesPartialName(metadata.buildMethodName, partial)) {
            var item = new CompletionItem();
            item.label = metadata.buildMethodName;
            item.kind = CompletionItemKind.Method;
            item.insertText = metadata.buildMethodName + "()";
            item.insertTextFormat = InsertTextFormat.PlainText;
            item.detail = "(generated by Lombok builder)";
            list.add(item);
        }
        return new CompletionList(false, list);
    }

    private static String resolveTypeName(
            CompileTask task, CompilerProvider compiler, CompilationUnitTree root, String simpleName) {
        var file = java.nio.file.Paths.get(root.getSourceFile().toUri());
        var packageName = FileStore.packageName(file);
        if (packageName != null && !packageName.isBlank()) {
            var candidate = packageName + "." + simpleName;
            if (compiler.findTypeDeclaration(candidate) != CompilerProvider.NOT_FOUND) {
                return candidate;
            }
        }
        for (var i : root.getImports()) {
            if (i.isStatic()) continue;
            var name = i.getQualifiedIdentifier().toString();
            if (name.endsWith("." + simpleName)) {
                return name;
            }
            if (name.endsWith(".*")) {
                var candidate = name.substring(0, name.length() - 2) + "." + simpleName;
                if (compiler.findTypeDeclaration(candidate) != CompilerProvider.NOT_FOUND) {
                    return candidate;
                }
            }
        }
        return null;
    }

    public static List<Location> findGeneratedMemberLocations(CompileTask task, String className, String memberName) {
        var locations = new ArrayList<Location>();
        var classTree = findClassTree(task.roots, className);
        if (classTree == null) return locations;

        var metadata = LombokSupport.analyze(classTree);
        if (!LombokSupport.hasLombokAnnotations(metadata)) return locations;

        var trees = Trees.instance(task.task);
        var field = metadata.fieldForGetter(memberName);
        if (field == null) {
            field = metadata.fieldForSetter(memberName);
        }
        if (field == null) return locations;

        for (var root : task.roots) {
            var path = trees.getPath(root, field);
            if (path != null) {
                var fieldName = field.getName().toString();
                var location = FindHelper.location(task, path, fieldName);
                locations.add(location);
                break;
            }
        }
        return locations;
    }

    public static boolean shouldSuppressUnusedField(
            Element unusedEl, CompileTask task, LombokMetadataCache cache) {
        if (unusedEl == null || unusedEl.getKind() != ElementKind.FIELD) return false;
        var parent = unusedEl.getEnclosingElement();
        if (!(parent instanceof TypeElement)) return false;
        var className = ((TypeElement) parent).getQualifiedName().toString();
        if (className.isEmpty()) return false;
        var metadata = metadataForClass(task, className, cache);
        return metadata != null;
    }

    public static List<org.javacs.lsp.Diagnostic> constructorDiagnostics(
            CompileTask task, LombokMetadataCache cache, CompilationUnitTree root) {
        if (cache == null) return List.of();
        var diagnostics = new ArrayList<org.javacs.lsp.Diagnostic>();
        var trees = Trees.instance(task.task);
        new TreePathScanner<Void, Void>() {
            @Override
            public Void visitNewClass(com.sun.source.tree.NewClassTree tree, Void __) {
                var idPath = new TreePath(getCurrentPath(), tree.getIdentifier());
                var typeMirror = trees.getTypeMirror(idPath);
                if (!(typeMirror instanceof DeclaredType)) {
                    return super.visitNewClass(tree, __);
                }
                var typeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();
                var className = typeElement.getQualifiedName().toString();
                var metadata = metadataForClass(task, className, cache);
                if (metadata == null) return super.visitNewClass(tree, __);

                var allowedCounts = constructorParamCounts(metadata);
                var builderAllArgsCount = builderAllArgsCount(metadata);
                var samePackage = samePackage(root, className);
                if (builderAllArgsCount >= 0 && samePackage) {
                    allowedCounts.add(builderAllArgsCount);
                }
                if (allowedCounts.isEmpty() && builderAllArgsCount < 0) return super.visitNewClass(tree, __);

                var argCount = tree.getArguments().size();
                if (allowedCounts.contains(argCount)) {
                    return super.visitNewClass(tree, __);
                }

                if (builderAllArgsCount >= 0 && !samePackage && argCount == builderAllArgsCount) {
                    var start = trees.getSourcePositions().getStartPosition(root, tree.getIdentifier());
                    var end = trees.getSourcePositions().getEndPosition(root, tree.getIdentifier());
                    var diagnostic = new org.javacs.lsp.Diagnostic();
                    diagnostic.severity = DiagnosticSeverity.Error;
                    diagnostic.code = "lombok.err.constructor_access";
                    diagnostic.message =
                            String.format(
                                    "'%s' is not public in '%s'. Cannot be accessed from outside package",
                                    constructorSignatureLabel(typeElement.getSimpleName().toString(), metadata, ConstructorKind.ALL),
                                    className);
                    diagnostic.range = range(root, start, end);
                    diagnostics.add(diagnostic);
                    return super.visitNewClass(tree, __);
                }

                var start = trees.getSourcePositions().getStartPosition(root, tree.getIdentifier());
                var end = trees.getSourcePositions().getEndPosition(root, tree.getIdentifier());
                var diagnostic = new org.javacs.lsp.Diagnostic();
                diagnostic.severity = DiagnosticSeverity.Error;
                diagnostic.code = "lombok.err.constructor_args";
                diagnostic.message = constructorErrorMessage(typeElement, metadata, builderAllArgsCount);
                diagnostic.range = range(root, start, end);
                diagnostics.add(diagnostic);
                return super.visitNewClass(tree, __);
            }
        }.scan(root, null);
        return diagnostics;
    }

    public static List<org.javacs.lsp.Diagnostic> builderConstructorDiagnostics(
            CompileTask task, CompilationUnitTree root) {
        var diagnostics = new ArrayList<org.javacs.lsp.Diagnostic>();
        var trees = Trees.instance(task.task);
        new TreePathScanner<Void, Void>() {
            @Override
            public Void visitClass(ClassTree tree, Void __) {
                var metadata = LombokSupport.analyze(tree);
                var className =
                        metadata != null && tree != null && tree.getSimpleName() != null
                                ? tree.getSimpleName().toString()
                                : "<unknown>";
                if (!metadata.hasBuilder
                        || !metadata.hasBuilderAnnotation
                        || !metadata.hasNoArgsConstructorAnnotation
                        || metadata.hasAllArgsConstructorAnnotation
                        || metadata.hasRequiredArgsConstructorAnnotation
                        || metadata.isRecord) {
                    return super.visitClass(tree, __);
                }

                var start = trees.getSourcePositions().getStartPosition(root, tree);
                var end = trees.getSourcePositions().getEndPosition(root, tree);
                for (var annotation : tree.getModifiers().getAnnotations()) {
                    var annotationType = annotation.getAnnotationType().toString();
                    var lastDot = annotationType.lastIndexOf('.');
                    var simpleName = lastDot >= 0 ? annotationType.substring(lastDot + 1) : annotationType;
                    if (simpleName.equals("Builder")) {
                        start = trees.getSourcePositions().getStartPosition(root, annotation);
                        end = trees.getSourcePositions().getEndPosition(root, annotation);
                        break;
                    }
                }
                var diagnostic = new org.javacs.lsp.Diagnostic();
                diagnostic.severity = DiagnosticSeverity.Error;
                diagnostic.code = "lombok.err.builder_constructor";
                diagnostic.message = "Lombok @Builder needs a proper constructor for this class";
                diagnostic.range = range(root, start, end);
                diagnostics.add(diagnostic);
                return super.visitClass(tree, __);
            }
        }.scan(root, null);
        return diagnostics;
    }

    public static SignatureHelp signatureHelpForMethod(
            CompileTask task,
            MemberSelectTree select,
            int activeParameter,
            LombokMetadataCache cache) {
        var trees = Trees.instance(task.task);
        var methodName = select.getIdentifier().toString();
        if (select.getExpression() instanceof MethodInvocationTree) {
            var builderHelp =
                    builderSignatureHelpForInvocation(
                            task, (MethodInvocationTree) select.getExpression(), methodName, activeParameter, cache);
            if (builderHelp != null) {
                return builderHelp;
            }
        }
        var path = trees.getPath(task.root(), select.getExpression());
        var type = typeElement(trees.getTypeMirror(path));
        if (type == null) return null;
        var metadata = metadataForClass(task, type.getQualifiedName().toString(), cache);
        if (metadata == null) return null;

        var fieldForSetter = metadata.fieldForSetter(methodName);
        if (fieldForSetter != null) {
            var info = new SignatureInformation();
            info.label = methodName;
            info.parameters = List.of(parameterInfo(fieldForSetter));
            addFancyLabel(info);
            return new SignatureHelp(List.of(info), 0, activeParameter);
        }
        var fieldForGetter = metadata.fieldForGetter(methodName);
        if (fieldForGetter != null) {
            var info = new SignatureInformation();
            info.label = methodName;
            info.parameters = List.of();
            addFancyLabel(info);
            return new SignatureHelp(List.of(info), 0, 0);
        }
        return null;
    }

    private static SignatureHelp builderSignatureHelpForInvocation(
            CompileTask task,
            MethodInvocationTree invocation,
            String methodName,
            int activeParameter,
            LombokMetadataCache cache) {
        var trees = Trees.instance(task.task);
        var select = invocation.getMethodSelect();
        if (!(select instanceof MemberSelectTree)) return null;
        var memberSelect = (MemberSelectTree) select;
        var builderName = memberSelect.getIdentifier().toString();
        var ownerPath = trees.getPath(task.root(), memberSelect.getExpression());
        if (ownerPath == null) return null;
        var ownerElement = trees.getElement(ownerPath);
        if (!(ownerElement instanceof TypeElement)) return null;
        var ownerType = (TypeElement) ownerElement;

        var metadata = metadataForClass(task, ownerType.getQualifiedName().toString(), cache);
        if (metadata == null || !metadata.hasBuilder) return null;
        if (!builderName.equals(metadata.builderMethodName)) return null;
        if (metadata.explicitMethodNames.contains(metadata.builderMethodName)) return null;
        if (metadata.explicitInnerTypeNames.contains(metadata.builderClassName)) return null;

        if (methodName.equals(metadata.buildMethodName)
                && !metadata.explicitBuilderMethodNames.contains(metadata.buildMethodName)) {
            var info = new SignatureInformation();
            info.label = metadata.buildMethodName;
            info.parameters = List.of();
            addFancyLabel(info);
            return new SignatureHelp(List.of(info), 0, 0);
        }
        if (metadata.isGeneratedBuilderMethod(methodName)) {
            var field = metadata.builderParamForName(methodName);
            if (field == null) return null;
            var info = new SignatureInformation();
            info.label = methodName;
            info.parameters = List.of(parameterInfo(field));
            addFancyLabel(info);
            return new SignatureHelp(List.of(info), 0, activeParameter);
        }
        return null;
    }

    public static SignatureHelp signatureHelpForConstructor(
            CompileTask task,
            com.sun.source.tree.NewClassTree tree,
            int activeParameter,
            LombokMetadataCache cache) {
        var trees = Trees.instance(task.task);
        var idPath = trees.getPath(task.root(), tree.getIdentifier());
        if (idPath == null) return null;
        var typeMirror = trees.getTypeMirror(idPath);
        if (!(typeMirror instanceof DeclaredType)) return null;
        var typeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();
        var metadata = metadataForClass(task, typeElement.getQualifiedName().toString(), cache);
        if (metadata == null) return null;
        if (metadata.isRecord || metadata.hasExplicitConstructor) return null;

        var signatures = new ArrayList<SignatureInformation>();
        if (metadata.hasNoArgsConstructor) {
            var info = new SignatureInformation();
            info.label = typeElement.getSimpleName().toString();
            info.parameters = List.of();
            addFancyLabel(info);
            signatures.add(info);
        }
        if (metadata.hasRequiredArgsConstructor) {
            var info = constructorSignature(typeElement, metadata, ConstructorKind.REQUIRED);
            if (info != null) signatures.add(info);
        }
        if (metadata.hasAllArgsConstructor || metadata.hasData || metadata.hasValue) {
            var info = constructorSignature(typeElement, metadata, ConstructorKind.ALL);
            if (info != null) signatures.add(info);
        }
        if (signatures.isEmpty()) return null;
        return new SignatureHelp(signatures, 0, activeParameter);
    }

    public static org.javacs.lsp.Diagnostic adjustDiagnostic(
            CompileTask task,
            LombokMetadataCache cache,
            javax.tools.Diagnostic<? extends JavaFileObject> d,
            CompilationUnitTree root) {
        if (cache == null) return null;
        var code = d.getCode();
        if (code == null || !code.startsWith("compiler.err.cant.resolve")) {
            return null;
        }
        var message = d.getMessage(null);
        if (message == null) return null;

        var methodPattern = java.util.regex.Pattern.compile("method\\s+(\\w+)\\s*\\(([^)]*)\\)");
        var methodMatcher = methodPattern.matcher(message);
        if (!methodMatcher.find()) return null;

        var methodName = methodMatcher.group(1);
        var params = methodMatcher.group(2);
        var paramTypes = parseMethodParamTypes(params);
        if (paramTypes.size() != 1) return null;

        var classPattern = java.util.regex.Pattern.compile("location:.*(?:of type|class)\\s+([\\w.]+)");
        var classMatcher = classPattern.matcher(message);
        if (!classMatcher.find()) return null;

        var className = classMatcher.group(1);
        var metadata = cache.get(className, task.roots);
        if (metadata == null) return null;

        var field = metadata.fieldForSetter(methodName);
        if (field == null) return null;

        var expectedType = field.getType().toString();
        var actualType = paramTypes.get(0);
        if (typesMatch(expectedType, actualType)) {
            return null;
        }

        var start = d.getStartPosition();
        var end = d.getEndPosition();
        var diagnostic = new org.javacs.lsp.Diagnostic();
        diagnostic.severity = DiagnosticSeverity.Error;
        diagnostic.code = "lombok.err.type_mismatch";
        diagnostic.message =
                String.format("Argument type mismatch: expected %s but found %s", expectedType, actualType);
        diagnostic.range = range(root, start, end);
        return diagnostic;
    }

    public static boolean shouldFilterDiagnostic(
            CompileTask task, LombokMetadataCache cache, javax.tools.Diagnostic<? extends JavaFileObject> d) {
        if (cache == null) return false;
        var code = d.getCode();
        if (code == null || !code.startsWith("compiler.err.cant.resolve")) {
            return false;
        }
        var message = d.getMessage(null);
        if (message == null) return false;

        var methodPattern = java.util.regex.Pattern.compile("method\\s+(\\w+)\\s*\\(([^)]*)\\)");
        var methodMatcher = methodPattern.matcher(message);
        if (methodMatcher.find()) {
            var methodName = methodMatcher.group(1);
            var params = methodMatcher.group(2);
            var paramTypes = parseMethodParamTypes(params);

            var classPattern = java.util.regex.Pattern.compile("location:.*(?:of type|class)\\s+([\\w.]+)");
            var classMatcher = classPattern.matcher(message);
            if (classMatcher.find()) {
                var className = classMatcher.group(1);
                return isGeneratedMemberOfClass(task, cache, className, methodName, paramTypes);
            }
        }

        var variablePattern = java.util.regex.Pattern.compile("variable\\s+(\\w+)");
        var variableMatcher = variablePattern.matcher(message);
        if (variableMatcher.find()) {
            var variableName = variableMatcher.group(1);
            var classPattern = java.util.regex.Pattern.compile("location:.*(?:of type|class)\\s+([\\w.]+)");
            var classMatcher = classPattern.matcher(message);
            if (classMatcher.find()) {
                var className = classMatcher.group(1);
                return isGeneratedMemberOfClass(task, cache, className, variableName, null);
            }
        }

        return false;
    }

    public static List<Location> findAccessorReferences(
            CompilerProvider compiler,
            String className,
            String fieldName,
            LombokMetadataCache cache) {
        var metadata = metadataForClassName(compiler, className, cache);
        if (metadata == null || !LombokSupport.hasLombokAnnotations(metadata)) return List.of();
        if (!metadata.fieldsByName.containsKey(fieldName)) return List.of();

        var getterName = metadata.getterNameForField(fieldName);
        var setterName = metadata.setterNameForField(fieldName);
        var accessorNames = new HashSet<String>();
        if (getterName != null) accessorNames.add(getterName);
        if (setterName != null) accessorNames.add(setterName);
        if (accessorNames.isEmpty()) return List.of();

        var files = new HashSet<java.nio.file.Path>();
        for (var accessorName : accessorNames) {
            for (var f : compiler.findMemberReferences(className, accessorName)) {
                files.add(f);
            }
        }
        if (files.isEmpty()) return List.of();

        var sources = new ArrayList<JavaFileObject>();
        for (var f : files) {
            sources.add(new SourceFileObject(f));
        }
        var classSource = compiler.findTypeDeclaration(className);
        if (classSource != null && !classSource.equals(CompilerProvider.NOT_FOUND)) {
            var alreadyIncluded =
                    sources.stream()
                            .anyMatch(source -> source.toUri().equals(classSource.toUri()));
            if (!alreadyIncluded) {
                sources.add(new SourceFileObject(classSource));
            }
        }

        try (var task = compiler.compile(sources)) {
            var trees = Trees.instance(task.task);
            var types = task.task.getTypes();
            var targetType = task.task.getElements().getTypeElement(className);
            if (targetType == null) return List.of();

            var paths = new ArrayList<TreePath>();
            for (var root : task.roots) {
                new AccessorReferenceScanner(trees, types, targetType, accessorNames, className)
                        .scan(root, paths);
            }
            var locations = new ArrayList<Location>();
            for (var path : paths) {
                locations.add(FindHelper.location(task, path));
            }
            return locations;
        }
    }

    private static LombokMetadata metadataForClassName(
            CompilerProvider compiler, String className, LombokMetadataCache cache) {
        if (cache != null) {
            var refreshed = cache.getFromSource(className);
            if (refreshed != null) return refreshed;
        }
        var sourceFile = compiler.findTypeDeclaration(className);
        if (sourceFile == null || sourceFile.equals(CompilerProvider.NOT_FOUND)) {
            return null;
        }
        var parse = compiler.parse(sourceFile);
        var classTree = findClassTree(List.of(parse.root), className);
        if (classTree == null) return null;
        var metadata = LombokSupport.analyze(classTree);
        if (!LombokSupport.hasLombokAnnotations(metadata)) return null;
        return metadata;
    }

    private static boolean isGeneratedMemberOfClass(
            CompileTask task,
            LombokMetadataCache cache,
            String className,
            String memberName,
            List<String> paramTypes) {
        var metadata = cache.get(className, task.roots);
        if (metadata == null && className.endsWith("Builder")) {
            var owner = className.substring(0, className.length() - "Builder".length());
            metadata = cache.get(owner, task.roots);
            if (metadata != null && !metadata.builderClassName.equals(simpleName(className))) {
                metadata = null;
            }
        }
        if (metadata == null) {
            return false;
        }
        if (paramTypes != null) {
            if (paramTypes.isEmpty()) {
                if (metadata.isGeneratedGetter(memberName) || metadata.isGeneratedSpecialMethod(memberName)) {
                    return true;
                }
                if (metadata.hasBuilder
                        && memberName.equals(metadata.builderMethodName)
                        && !metadata.explicitMethodNames.contains(metadata.builderMethodName)
                        && !metadata.explicitInnerTypeNames.contains(metadata.builderClassName)) {
                    return true;
                }
                return metadata.hasBuilder
                        && memberName.equals(metadata.buildMethodName)
                        && !metadata.explicitBuilderMethodNames.contains(metadata.buildMethodName)
                        && !metadata.explicitInnerTypeNames.contains(metadata.builderClassName);
            }
            if (paramTypes.size() == 1) {
                var field = metadata.fieldForSetter(memberName);
                if (field != null && typesMatch(field.getType().toString(), paramTypes.get(0))) {
                    return true;
                }
                if (metadata.hasBuilder
                        && !metadata.explicitInnerTypeNames.contains(metadata.builderClassName)
                        && metadata.isGeneratedBuilderMethod(memberName)) {
                    var builderField = metadata.builderParamForName(memberName);
                    if (builderField != null
                            && typesMatch(builderField.getType().toString(), paramTypes.get(0))) {
                        return true;
                    }
                }
                return metadata.hasEqualsAndHashCode
                        && memberName.equals("equals")
                        && isObjectType(paramTypes.get(0));
            }
            return false;
        }
        return metadata.isGeneratedGetter(memberName)
                || metadata.isGeneratedSetter(memberName)
                || metadata.isGeneratedSpecialMethod(memberName)
                || (metadata.hasBuilder
                    && !metadata.explicitInnerTypeNames.contains(metadata.builderClassName)
                    && (memberName.equals(metadata.builderMethodName)
                        || metadata.isGeneratedBuilderMethod(memberName)));
    }

    private static String simpleName(String className) {
        var lastDot = className.lastIndexOf('.');
        if (lastDot >= 0) return className.substring(lastDot + 1);
        return className;
    }

    private static ClassTree findClassTree(List<CompilationUnitTree> roots, String qualifiedName) {
        var parts = qualifiedName.split("\\.");
        var simpleClassName = parts[parts.length - 1];
        var packageName = qualifiedName.substring(0, Math.max(0, qualifiedName.length() - simpleClassName.length() - 1));

        for (var root : roots) {
            var rootPackage = root.getPackage();
            if (rootPackage == null) {
                if (!packageName.isEmpty()) continue;
            } else {
                var rootPackageName = rootPackage.getPackageName().toString();
                if (!rootPackageName.equals(packageName)) continue;
            }

            for (var typeDecl : root.getTypeDecls()) {
                if (typeDecl.getKind() == Tree.Kind.CLASS) {
                    var classTree = (ClassTree) typeDecl;
                    if (classTree.getSimpleName().toString().equals(simpleClassName)) {
                        return classTree;
                    }
                }
            }
        }
        return null;
    }

    private static List<String> parseMethodParamTypes(String params) {
        if (params == null) return List.of();
        var trimmed = params.trim();
        if (trimmed.isEmpty()) return List.of();
        var parts = trimmed.split(",");
        var result = new ArrayList<String>();
        for (var part : parts) {
            var p = part.trim();
            if (!p.isEmpty()) {
                result.add(p);
            }
        }
        return result;
    }

    private static boolean typesMatch(String expectedType, String actualType) {
        return normalizeType(expectedType).equals(normalizeType(actualType));
    }

    private static String normalizeType(String typeName) {
        var type = typeName.replace(" ", "");
        type = type.replaceAll("<.*>", "");
        var arraySuffix = "";
        while (type.endsWith("[]")) {
            arraySuffix += "[]";
            type = type.substring(0, type.length() - 2);
        }
        var lastDot = type.lastIndexOf('.');
        var simple = lastDot >= 0 ? type.substring(lastDot + 1) : type;
        return simple + arraySuffix;
    }

    private static boolean isObjectType(String typeName) {
        var normalized = normalizeType(typeName);
        return normalized.equals("Object");
    }

    private static List<Integer> constructorParamCounts(LombokMetadata metadata) {
        if (metadata.isRecord || metadata.hasExplicitConstructor) {
            return List.of();
        }
        var counts = new HashSet<Integer>();
        if (metadata.hasNoArgsConstructor) {
            counts.add(0);
        }
        if (metadata.hasRequiredArgsConstructor
                && !(metadata.hasBuilder
                        && metadata.builderSource == LombokMetadata.BuilderSource.CLASS
                        && !metadata.hasRequiredArgsConstructorAnnotation)) {
            counts.add(requiredFieldCount(metadata));
        }
        if (metadata.hasAllArgsConstructor) {
            counts.add(allInstanceFieldCount(metadata));
        }
        return new ArrayList<>(counts);
    }

    private static int builderAllArgsCount(LombokMetadata metadata) {
        if (!metadata.hasBuilder) return -1;
        if (metadata.builderSource != LombokMetadata.BuilderSource.CLASS) return -1;
        if (metadata.hasExplicitConstructor) return -1;
        if (metadata.hasAllArgsConstructor || metadata.hasValue) return -1;
        return allInstanceFieldCount(metadata);
    }

    private static boolean samePackage(CompilationUnitTree root, String className) {
        var rootPackage = root.getPackageName() == null ? "" : root.getPackageName().toString();
        var classPackage = packageName(className);
        return Objects.equals(rootPackage, classPackage);
    }

    private static String packageName(String className) {
        var lastDot = className.lastIndexOf('.');
        if (lastDot < 0) return "";
        return className.substring(0, lastDot);
    }

    private static String constructorErrorMessage(
            TypeElement typeElement, LombokMetadata metadata, int builderAllArgsCount) {
        var name = typeElement.getSimpleName().toString();
        var signatures = new ArrayList<String>();
        if (metadata.hasNoArgsConstructor) {
            signatures.add(name + "()");
        }
        if (metadata.hasRequiredArgsConstructor
                && !(metadata.hasBuilder
                        && metadata.builderSource == LombokMetadata.BuilderSource.CLASS
                        && !metadata.hasRequiredArgsConstructorAnnotation)) {
            signatures.add(constructorSignatureLabel(name, metadata, ConstructorKind.REQUIRED));
        }
        if (metadata.hasAllArgsConstructor) {
            signatures.add(constructorSignatureLabel(name, metadata, ConstructorKind.ALL));
        } else if (builderAllArgsCount >= 0) {
            signatures.add(constructorSignatureLabel(name, metadata, ConstructorKind.ALL));
        }
        if (signatures.isEmpty()) {
            return String.format("Constructor %s cannot be applied to given arguments", name);
        }
        return "Available constructors: " + String.join(", ", signatures);
    }

    private static String constructorSignatureLabel(
            String name, LombokMetadata metadata, ConstructorKind kind) {
        var params = new ArrayList<String>();
        if (kind == ConstructorKind.ALL) {
            for (var field : metadata.allFields) {
                if (!isStatic(field)) {
                    params.add(field.getType() + " " + field.getName());
                }
            }
        } else {
            for (var field : metadata.allFields) {
                if (isRequiredField(field)) {
                    params.add(field.getType() + " " + field.getName());
                }
            }
        }
        return name + "(" + String.join(", ", params) + ")";
    }

    private static int requiredFieldCount(LombokMetadata metadata) {
        var count = 0;
        for (var field : metadata.allFields) {
            if (isRequiredField(field)) {
                count++;
            }
        }
        return count;
    }

    private static int allInstanceFieldCount(LombokMetadata metadata) {
        var count = 0;
        for (var field : metadata.allFields) {
            if (!isStatic(field)) {
                count++;
            }
        }
        return count;
    }

    private static boolean isFinal(VariableTree field) {
        for (var mod : field.getModifiers().getFlags()) {
            if (mod.name().equals("FINAL")) {
                return true;
            }
        }
        return false;
    }

    private static boolean isStatic(VariableTree field) {
        for (var mod : field.getModifiers().getFlags()) {
            if (mod.name().equals("STATIC")) {
                return true;
            }
        }
        return false;
    }

    private static boolean isRequiredField(VariableTree field) {
        if (isStatic(field)) return false;
        if (field.getInitializer() != null) return false;
        if (isFinal(field)) return true;
        return hasNonNullAnnotation(field);
    }

    private static boolean hasNonNullAnnotation(VariableTree field) {
        for (var annotation : field.getModifiers().getAnnotations()) {
            var annotationType = annotation.getAnnotationType().toString();
            var lastDot = annotationType.lastIndexOf('.');
            var simpleName = lastDot >= 0 ? annotationType.substring(lastDot + 1) : annotationType;
            if (simpleName.equals("NonNull")) {
                return true;
            }
        }
        return false;
    }

    private enum ConstructorKind {
        REQUIRED,
        ALL
    }

    private static SignatureInformation constructorSignature(
            TypeElement typeElement, LombokMetadata metadata, ConstructorKind kind) {
        var info = new SignatureInformation();
        info.label = typeElement.getSimpleName().toString();
        var params = new ArrayList<ParameterInformation>();
        if (kind == ConstructorKind.ALL) {
            for (var field : metadata.allFields) {
                if (!isStatic(field)) {
                    params.add(parameterInfo(field));
                }
            }
        } else {
            for (var field : metadata.allFields) {
                if (isRequiredField(field)) {
                    params.add(parameterInfo(field));
                }
            }
        }
        info.parameters = params;
        addFancyLabel(info);
        return info;
    }

    private static ParameterInformation parameterInfo(VariableTree field) {
        var info = new ParameterInformation();
        info.label = field.getType() + " " + field.getName();
        return info;
    }

    private static void addFancyLabel(SignatureInformation info) {
        var join = new java.util.StringJoiner(", ");
        for (var p : info.parameters) {
            join.add(p.label);
        }
        info.label = info.label + "(" + join + ")";
    }

    private static TypeElement typeElement(javax.lang.model.type.TypeMirror type) {
        if (type instanceof DeclaredType) {
            var declared = (DeclaredType) type;
            return (TypeElement) declared.asElement();
        }
        if (type instanceof TypeVariable) {
            var variable = (TypeVariable) type;
            return typeElement(variable.getUpperBound());
        }
        return null;
    }

    private static Range range(CompilationUnitTree root, long start, long end) {
        var lines = root.getLineMap();
        var startLine = (int) lines.getLineNumber(start);
        var startColumn = (int) lines.getColumnNumber(start);
        var startPos = new Position(startLine - 1, startColumn - 1);
        var endLine = (int) lines.getLineNumber(end);
        var endColumn = (int) lines.getColumnNumber(end);
        var endPos = new Position(endLine - 1, endColumn - 1);
        return new Range(startPos, endPos);
    }

    private static final class AccessorReferenceScanner extends TreePathScanner<Void, List<TreePath>> {
        private final Trees trees;
        private final Types types;
        private final TypeElement targetType;
        private final Set<String> accessorNames;
        private final String targetClassName;

        AccessorReferenceScanner(
                Trees trees, Types types, TypeElement targetType, Set<String> accessorNames, String targetClassName) {
            this.trees = trees;
            this.types = types;
            this.targetType = targetType;
            this.accessorNames = accessorNames;
            this.targetClassName = targetClassName;
        }

        @Override
        public Void visitMethodInvocation(MethodInvocationTree tree, List<TreePath> paths) {
            var select = tree.getMethodSelect();
            if (select instanceof MemberSelectTree) {
                var memberSelect = (MemberSelectTree) select;
                var name = memberSelect.getIdentifier().toString();
                if (accessorNames.contains(name) && isReceiverMatch(memberSelect)) {
                    paths.add(new TreePath(getCurrentPath(), memberSelect));
                }
            } else if (select instanceof IdentifierTree) {
                var ident = (IdentifierTree) select;
                var name = ident.getName().toString();
                if (accessorNames.contains(name) && isEnclosingTypeMatch()) {
                    paths.add(new TreePath(getCurrentPath(), ident));
                }
            }
            return super.visitMethodInvocation(tree, paths);
        }

        private boolean isReceiverMatch(MemberSelectTree select) {
            var exprPath = new TreePath(new TreePath(getCurrentPath(), select), select.getExpression());
            var type = trees.getTypeMirror(exprPath);
            if (type == null || type.getKind() != TypeKind.DECLARED) return false;
            var declared = (DeclaredType) type;
            if (targetType == null) return false;
            return types.isSameType(types.erasure(declared), types.erasure(targetType.asType()));
        }

        private boolean isEnclosingTypeMatch() {
            var path = getCurrentPath();
            while (path != null) {
                var leaf = path.getLeaf();
                if (leaf instanceof ClassTree) {
                    var typeEl = (TypeElement) trees.getElement(path);
                    if (typeEl == null) return false;
                    if (targetType == null) return false;
                    return types.isSameType(
                            types.erasure(typeEl.asType()), types.erasure(targetType.asType()));
                }
                path = path.getParentPath();
            }
            return false;
        }
    }
}
