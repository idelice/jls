package org.javacs;

import com.sun.source.tree.ClassTree;
import com.sun.source.tree.VariableTree;
import javax.lang.model.element.ElementKind;
import java.util.*;
import java.util.logging.Logger;

/**
 * Utility for analyzing Lombok annotations and determining which members are generated.
 * This allows JLS to provide Lombok support without relying on javac's broken AP infrastructure.
 */
public class LombokSupport {
    private static final Logger LOG = Logger.getLogger("main");

    /**
     * Analyze a class tree to extract Lombok metadata.
     * Returns information about which members are generated by Lombok.
     *
     * @param classTree the class to analyze
     * @return metadata about Lombok-generated members
     */
    public static LombokMetadata analyze(ClassTree classTree) {
        var metadata = new LombokMetadata();

        if (classTree == null) {
            return metadata;
        }

        metadata.isRecord = classTree.getKind() == com.sun.source.tree.Tree.Kind.RECORD;
        var isEnum = classTree.getKind() == com.sun.source.tree.Tree.Kind.ENUM;
        metadata.builderClassName = classTree.getSimpleName().toString() + "Builder";

        extractExplicitMembers(classTree, metadata);

        // Extract all fields from the class
        extractFields(classTree, metadata);

        // Check for Lombok annotations
        checkAnnotations(classTree, metadata, isEnum);

        // Method/constructor-level @Builder
        extractBuilderFromMethods(classTree, metadata);

        // Finalize builder params for class-level @Builder
        finalizeBuilderParams(metadata);

        return metadata;
    }

    /**
     * Extract all fields from a class tree.
     */
    private static void extractFields(ClassTree classTree, LombokMetadata metadata) {
        for (var member : classTree.getMembers()) {
            if (member.getKind().name().equals("VARIABLE")) {
                var field = (VariableTree) member;
                metadata.allFields.add(field);
                metadata.fieldsByName.put(field.getName().toString(), field);
                extractFieldAnnotations(field, metadata);
            }
        }
    }

    private static void extractExplicitMembers(ClassTree classTree, LombokMetadata metadata) {
        for (var member : classTree.getMembers()) {
            if (member instanceof com.sun.source.tree.MethodTree) {
                var method = (com.sun.source.tree.MethodTree) member;
                var name = method.getName().toString();
                // Only track instance methods, not static methods
                // Static methods don't conflict with instance getters/setters
                var isStatic = method.getModifiers().getFlags().contains(javax.lang.model.element.Modifier.STATIC);
                if (!isStatic) {
                    metadata.explicitMethodNames.add(name);
                }
                if (method.getReturnType() == null) {
                    metadata.hasExplicitConstructor = true;
                }
            } else if (member instanceof ClassTree) {
                var inner = (ClassTree) member;
                var name = inner.getSimpleName().toString();
                metadata.explicitInnerTypeNames.add(name);
                if (name.equals(metadata.builderClassName)) {
                    for (var innerMember : inner.getMembers()) {
                        if (innerMember instanceof com.sun.source.tree.MethodTree) {
                            var method = (com.sun.source.tree.MethodTree) innerMember;
                            metadata.explicitBuilderMethodNames.add(method.getName().toString());
                        }
                    }
                }
            }
        }
    }

    private static void extractFieldAnnotations(VariableTree field, LombokMetadata metadata) {
        for (var annotation : field.getModifiers().getAnnotations()) {
            var annotationType = annotation.getAnnotationType().toString();
            var simpleName = getSimpleName(annotationType);
            switch (simpleName) {
                case "Getter" -> metadata.getterFields.add(field.getName().toString());
                case "Setter" -> metadata.setterFields.add(field.getName().toString());
            }
        }
    }

    /**
     * Check what Lombok annotations are present on the class.
     * @param isEnum whether this class is an enum (enums don't support generated constructors)
     */
    private static void checkAnnotations(ClassTree classTree, LombokMetadata metadata, boolean isEnum) {
        for (var annotation : classTree.getModifiers().getAnnotations()) {
            var annotationType = annotation.getAnnotationType().toString();
            var simpleName = getSimpleName(annotationType);

            switch (simpleName) {
                case "Data" -> {
                    metadata.hasData = true;
                    metadata.hasGetter = true;
                    metadata.hasSetter = true;
                    metadata.hasToString = true;
                    metadata.hasEqualsAndHashCode = true;
                    metadata.hasRequiredArgsConstructor = true;
                }
                case "Getter" -> metadata.hasGetter = true;
                case "Setter" -> metadata.hasSetter = true;
                case "ToString" -> {
                    metadata.hasToString = true;
                    extractExcludedFields(annotation, metadata.excludedFromToString);
                }
                case "EqualsAndHashCode" -> {
                    metadata.hasEqualsAndHashCode = true;
                    extractExcludedFields(annotation, metadata.excludedFromEquals);
                }
                case "AllArgsConstructor" -> {
                    metadata.hasAllArgsConstructor = true;
                    metadata.hasAllArgsConstructorAnnotation = true;
                }
                case "RequiredArgsConstructor" -> {
                    metadata.hasRequiredArgsConstructor = true;
                    metadata.hasRequiredArgsConstructorAnnotation = true;
                }
                case "NoArgsConstructor" -> {
                    metadata.hasNoArgsConstructor = true;
                    metadata.hasNoArgsConstructorAnnotation = true;
                }
                case "Builder" -> {
                    metadata.hasBuilder = true;
                    metadata.hasBuilderAnnotation = true;
                }
                case "Value" -> {
                    metadata.hasValue = true;
                    metadata.hasGetter = true;
                    // Setters not generated for @Value (immutable)
                    metadata.hasToString = true;
                    metadata.hasEqualsAndHashCode = true;
                    metadata.hasAllArgsConstructor = true;
                }
                case "Slf4j" -> metadata.hasSlf4j = true;
            }
        }
    }

    private static void extractBuilderFromMethods(ClassTree classTree, LombokMetadata metadata) {
        for (var member : classTree.getMembers()) {
            if (member instanceof com.sun.source.tree.MethodTree) {
                var method = (com.sun.source.tree.MethodTree) member;
                var isConstructor = method.getReturnType() == null;
                for (var annotation : method.getModifiers().getAnnotations()) {
                    var annotationType = annotation.getAnnotationType().toString();
                    var simpleName = getSimpleName(annotationType);
                    if (!simpleName.equals("Builder")) continue;
                    metadata.hasBuilder = true;
                    metadata.builderSource =
                            isConstructor
                                    ? LombokMetadata.BuilderSource.CONSTRUCTOR
                                    : LombokMetadata.BuilderSource.METHOD;
                    for (var param : method.getParameters()) {
                        metadata.builderParams.add(param);
                        metadata.builderParamsByName.put(param.getName().toString(), param);
                    }
                    return;
                }
            }
        }
    }

    private static void finalizeBuilderParams(LombokMetadata metadata) {
        if (!metadata.hasBuilder) return;
        if (metadata.builderSource != LombokMetadata.BuilderSource.NONE) return;
        metadata.builderSource = LombokMetadata.BuilderSource.CLASS;
        for (var field : metadata.allFields) {
            if (field.getModifiers().getFlags().stream().anyMatch(m -> m.name().equals("STATIC"))) {
                continue;
            }
            metadata.builderParams.add(field);
            metadata.builderParamsByName.put(field.getName().toString(), field);
        }
    }

    /**
     * Extract the list of excluded fields from annotation parameters.
     * Example: @ToString(exclude = {"password", "secret"})
     */
    private static void extractExcludedFields(
            com.sun.source.tree.AnnotationTree annotation,
            Set<String> excluded) {
        // Note: This is a simplified implementation.
        // Full implementation would parse the annotation's arguments.
        // For now, we don't fully support exclude parameters - can be improved.
    }

    /**
     * Get simple name from fully qualified class name.
     * "lombok.Data" -> "Data"
     * "Data" -> "Data"
     */
    private static String getSimpleName(String fullName) {
        if (fullName == null) {
            return "";
        }
        var lastDot = fullName.lastIndexOf('.');
        if (lastDot >= 0) {
            return fullName.substring(lastDot + 1);
        }
        return fullName;
    }

    /**
     * Check if a class has any Lombok annotations that generate members.
     */
    public static boolean hasLombokAnnotations(LombokMetadata metadata) {
        return metadata.hasData ||
               metadata.hasGetter ||
               metadata.hasSetter ||
               metadata.hasToString ||
               metadata.hasEqualsAndHashCode ||
               metadata.hasAllArgsConstructor ||
               metadata.hasRequiredArgsConstructor ||
               metadata.hasBuilder ||
               metadata.hasValue ||
               metadata.hasSlf4j;
    }
}
